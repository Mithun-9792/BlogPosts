(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (global = global || self, factory(global.ReactEditor = {}, global.React));
}(this, (function (exports, React) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    var applyRange = function (range) {
        var selection = window.getSelection();
        if (selection) {
            selection.removeAllRanges();
            selection.addRange(range);
        }
    };
    var getRange = function () {
        var selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
            return selection.getRangeAt(0);
        }
        return null;
    };
    var moveToEnd = function (el) {
        el.focus();
        var selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
            selection.selectAllChildren(el); //range 选择obj下所有子内容
            selection.collapseToEnd(); //光标移至最后
        }
    };

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z = "/* add css styles here (optional) */\n\n.styles_editor__9lmdU {\n  white-space: pre-wrap;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  outline: 0; /* can be weird  overflowed */\n  cursor: text;\n}\n\n.styles_editor__9lmdU:empty:before {\n  content: attr(data-placeholder);\n  color: #b4b4c7;\n  cursor: inherit;\n}\n";
    var styles = {"editor":"styles_editor__9lmdU"};
    styleInject(css_248z);

    var forwardRef = React.forwardRef, useRef = React.useRef, useState = React.useState, useLayoutEffect = React.useLayoutEffect, useCallback = React.useCallback, useImperativeHandle = React.useImperativeHandle;
    var Editor = forwardRef(function (props, ref) {
        var _a;
        var value = props.value, defaultValue = props.defaultValue, className = props.className, placeholder = props.placeholder, allowInWebDrop = props.allowInWebDrop, processHTML = props.processHTML, processText = props.processText, onFocus = props.onFocus, onBlur = props.onBlur, onChange = props.onChange, onDrop = props.onDrop, onPaste = props.onPaste, restProps = __rest(props, ["value", "defaultValue", "className", "placeholder", "allowInWebDrop", "processHTML", "processText", "onFocus", "onBlur", "onChange", "onDrop", "onPaste"]);
        var onceChanged = (_a = useState(false), _a[0]), setOnceChanged = _a[1];
        var elRef = useRef(null);
        var rangeRef = useRef(null);
        var clearRange = useCallback(function () {
            rangeRef.current = null;
        }, []);
        var saveRange = useCallback(function () {
            var range = getRange();
            rangeRef.current = range;
        }, []);
        var restoreRange = useCallback(function () {
            var range = rangeRef.current;
            if (range) {
                applyRange(range);
            }
            else {
                var el = elRef.current;
                if (el)
                    moveToEnd(el);
            }
        }, []);
        var focus = useCallback(function () {
            var el = elRef.current;
            if (el)
                el.focus();
        }, []);
        var insertHTML = useCallback(function (html) {
            focus();
            if (processHTML)
                html = processHTML(html);
            document.execCommand('insertHTML', false, html);
        }, [processHTML]);
        var insertText = useCallback(function (text) {
            focus();
            if (processText)
                text = processText(text);
            document.execCommand('insertHTML', false, text);
        }, [processText]);
        var handleInput = useCallback(function () {
            var el = elRef.current;
            if (el) {
                // fix placeholder
                if (el.innerHTML === '\u0008' ||
                    el.innerHTML === '<br>' ||
                    el.innerHTML === '<div><br></div>') {
                    el.innerHTML = '';
                }
                setOnceChanged(true);
                var newValue = el.innerHTML;
                if (onChange)
                    onChange(newValue);
            }
        }, []);
        var handleFocus = useCallback(function (e) {
            restoreRange();
            if (onFocus)
                onFocus(e);
        }, []);
        var handleBlur = useCallback(function (e) {
            saveRange();
            if (onBlur)
                onBlur(e);
        }, []);
        var handleDrop = useCallback(function (e) {
            var files = e.dataTransfer.files || [];
            // avoid in-web drop unless set to allow
            if (files.length <= 0 && !allowInWebDrop) {
                e.preventDefault();
            }
            // avoid file-open as browser default
            if (files.length >= 1) {
                e.preventDefault();
            }
            if (onDrop)
                onDrop(e);
        }, [allowInWebDrop]);
        var handlePaste = useCallback(function (e) {
            // e.preventDefault();
            // // const types = e.clipboardData.types || []
            // // const items = e.clipboardData.items || []
            // let html = e.clipboardData.getData('text/html');
            // let text = e.clipboardData.getData('text/plain');
            // // @todo types & items
            // if (html) {
            //   insertHTML(html);
            // } else if (text) {
            //   insertText(text);
            // }
            // @todo
            if (onPaste)
                onPaste(e);
        }, [insertHTML, insertText]);
        useImperativeHandle(ref, function () {
            return {
                focus: focus,
                insertHTML: insertHTML,
                insertText: insertText,
            };
        }, [insertHTML, insertText]);
        useLayoutEffect(function () {
            var el = elRef.current;
            if (el && value !== undefined && value !== el.innerHTML) {
                var html = value;
                if (processHTML)
                    html = processHTML(html);
                el.innerHTML = html;
                clearRange();
            }
        }, [value, processHTML]);
        useLayoutEffect(function () {
            var el = elRef.current;
            if (el &&
                !onceChanged &&
                value === undefined &&
                defaultValue !== undefined &&
                defaultValue !== el.innerHTML) {
                var html = defaultValue;
                if (processHTML)
                    html = processHTML(html);
                el.innerHTML = html;
                clearRange();
            }
        }, [value, processHTML, defaultValue, onceChanged]);
        return (React.createElement("div", __assign({ ref: elRef, contentEditable: true, "data-placeholder": placeholder, className: [styles.editor, className].filter(Boolean).join(' '), onFocus: handleFocus, onBlur: handleBlur, onDrop: handleDrop, onPaste: handlePaste, onInput: handleInput }, restProps)));
    });

    exports.Editor = Editor;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
